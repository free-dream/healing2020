## 1. 架构设计

### 1.1 大体框架

这次治愈系算是第一次脱离以前的框架，自己仿造laravel的逻辑，MVC的设计模式设计了治愈系的架构：先有一个main.go充当程序入口，然后一个router.go当路由器，然后建了一个controller文件夹存控制器，再建了一个model文件夹存模型，最后又有一个pkg包存共同使用的工具函数等。然后当时没有想太多，就开工了。

这里第一个问题就是数据库没想好，导致后面设计好数据结构之后匆匆忙忙在model里补了一个statement的包来存数据库，后来又觉得应该统一连接，又在pkg里建了一个setting来写连接mysql和redis的函数，当然这几个连接写得有问题，这个后面说。这样的结构设计使得数据库部分很乱，如果是现在重新搭建的话，数据库部分我会独立出来，包含了表的声明，数据库的连接，假数据的批量插入接口，以及可以补上也可以不必的种子操作。还有一个问题是当时设立pkg的时候没有想到包不可以循环引用的问题，所以getconfig，cron，getuser等函数放的位置都出了些问题。

重新搭建：

```
main.go
router/rouer.go
controller/  =>  middleware/
                               普通控制器
                               abstract/
model/  =>  cron/
                        handle/
                        baseFunc/
database/  =>  statements/
							  seed/
                              conn/
pkg/  =>  tools/
                   e/
```

### 1.2 数据库设计

这次数据逻辑不算复杂，由于板块多且大多数关联不强，所以只要以核心的几条线为轴就能理清逻辑。user是中心，song，vod是治愈板块，deliver，comment是投递板块，special，subject是歌房板块，prize，lottery是抽奖版块，message，mailbox是聊天室，rank是排行榜。就这样搭建起大概网络。

但是实际还是有许多问题，最影响开发的是命名不规范的问题，这个后面说，其次便是设计没考虑一些更细节的东西。比如用户表由于用户的配置实在太多，不得不开了一个新表。比如点赞要考虑并发问题，建了一个点赞表。比如聊天室的实现属于知识盲区，最后并不需要mailbox;排行榜最后想了更好的解决方法，也不用rank表。

话说回来，数据表在开发中需要更改是不可避免的，这次的整体思路没有太大问题，缺的是开发经验，没能意识到实现需要的方法，导致表的设计出现了偏差，其次在一些数据量较大的表上并没能建好索引，这个是当时考虑有所欠缺的。还有一个就是开始很多思路都局限在了mysql上，而很少去使用redis，这个可以继续深入学习，开拓思路。

当然也有好的地方，一个是思路清晰，和开发的分工配合得很好;还有一个比较舒服的就是创建表的逻辑加上了自动迁移，使得后续在改数据库的时候比较丝滑。

ps：这里踩了一个坑，当时gorm用的是1.0版本的，对于数据表新增项是可以自动迁移的，但是修改默认值之类的就无法实现了，直到2.0更新了alter的一系列函数。

### 1.3 配置文件

建在healing2020/config下，有config.ini的配置文件，写有微信appid，secret;数据库用户密码;文件储存目录等信息。这个ini相较于yaml或者json这种结构来储存显得直观一些。

## 2 开始开发

### 2.1 接口文档

接口很难在第一次就给全的，总体而言逻辑还是比较清晰的，无外乎针对版块的各个功能按功能的区分，再加上几个全局通用的接口。

由于没有后台，接口在分群组就很直接，登录前登录后直接以api区分。

规范问题，好些接口并没有遵循restful规则，而且没用delete导致有些接口语义令人迷惑。

文档有两份，一份是readme，一份是线上文档，配置了swagger。但是两份都没做到同步更新，以及线上那份有bug，所以交流效率偏低。

### 2.2 排行榜

一开始是想着简单的轮询，建个rank表当作临时记录，需要就从这个表拿就行。但是这样太蠢了，就改成定时打包发给redis，拿的时候直接从redis拿，速度更快。

然后就踩了一个历时最长的坑，空指针。由于结构体数组属于slice，创建之后要make给地址，但是有时候查询没查到数据，逻辑代码又不给地址就直接操作，所以直接500。而这个没查到数据，gorm的错误捕捉也时灵时不灵（至少当时看来是这样），因此就用一个count先把数据数量拿到，有了count就好判断了。

然后就是一个rows的坑，gorm拿到批量数据后可以用rows函数迭代操作，但是rows是占用连接池的，如果没有及时关闭，大量操作后就会耗尽连接池。上线后出现了每隔一段时间所有接口都死等待状态，最后检查发现是用户排名的rows没有及时close。

然后有一个比较烦，最后处理也不是很好的点，就是时间问题。排行榜要日期，自然是体现在redis的keyname上，但是keyname要string，数据库给的是time.Time，简单的"5-10"这样不好加一迭代，所以绕了一圈用"5.10"然后又转成float64，这样绕来绕去，挺难看的。而且标准日期没有写进ini配置，变成了hardcode。

### 2.3 首页

首页的第一个难点是数据结构的设计，这是这种数据表结构设计的缺陷的体现，表间没有建立联系，全靠手动同步，导致了数据查询的时候比较麻烦，效率也低，在首页信息查询一块足足写了370行。首页分了12种类型，每种类型又有两种排序方式，我就把这些合并在了一个接口。但是这样一来接口流量变大，本身数据就多，想到这样肯定会爆，就把这些数据也塞进了redis。但是这样又出现了一个问题，就是有一个是推荐，这个请求需要用户的标签做筛选，因此最后的解决办法是从redis拿完封装好的数据后，拆开筛选，再加上点赞信息等，再封装发给前端，整体来说应该还好。

另外就是分页，gorm是没有分页函数的，因此要手写分页。这里由于早就把数据分开存好了，所以实现也只需要拿到数据，根据页数分。而由于听歌和唱歌并不同步，所以这里才发现接口设计的问题，每个页数都会发这一页的听歌和唱歌，这样大大浪费了流量，而且两边数量不同步，只要有一边完了就会报错。而这里也体现了代码的问题，尽管设计的耦合已经足够低了，代码依旧没写好，导致发现这个问题不好改接口，最后只能硬着头皮把报错逻辑改了，流量浪费只能暂时不去管。

### 2.4 治愈

整个治愈在开发前想得太简单了，当时只想着，不就是vod和song两个表的crud，也没什么复杂逻辑，于是就只写了个大概框架，等到快上线才发现一堆问题。当然这里有时间规划不合理的原因（拖延症），但是不管怎样，治愈这个版块写得确实拉跨。

这里有三大难题，第一个是点赞，一开始没想那么多，简简单单就在数据表加一个点赞数的项。然后并发就出问题，点1000个赞只有22成功加上，当然这里也是我理解错了事务，把事务当作互斥锁用了。现在看来，就是用gorm带的update for的行级锁也不太行，因为这样把整个记录锁住会影响其他地方其他模块对这个表其他数据的正常使用。这个解决办法有两种，一种是在mysql新建一个点赞表，这个点赞表可以全程序通用，只记录点赞人和点赞记录，这个解决了是否点赞的问题。然后也带来了一个坑，由于排行榜和首页都定时存redis，然后像随机排序是gorm没有的，因此要手写sql，但是又需要点赞排序，而点赞记录要实时的给，这样就很难受，差点就去写联表查询了。最后想了一个折中的办法，就是写一个把点赞更新到之前那个点赞数的项的函数，然后每次刷新前就执行一次，排序查询就直接用那个点赞数的项了;另一个方法是直接在redis上建点赞表，redis保证操作的原子性，又提高了效率，但是还没尝试过，不知道效果如何。

第二个难题是录音，这个没解决，后面没时间写了，甩锅给广晋师兄了。现在也试过这个了，难点在于拼接，以及类型转换。微信录音时长只有一分种，但是治愈系需求肯定不止1分钟，所以最后只能把几段发给后端来拼接。拼接要考虑音质不太受影响，所以选择高质量的speex模式，然后后端转成wav拼接，最后转成mp3发回给前端。这里涉及了很多类型转换，wav到mp3这个简单，ffmpeg就可以搞定，难的是speex转wav，这个地方有个坑，微信的speex并不是正常的speex，用官方开源工具解码是会失败的，需要特殊的speex解码工具，这里要去github找（当然部门服务器早就找好了，但是本地调试就要注意了）

第三个难题是点歌次数，这个为了保证原子性，直接每个用户建一个key-value，把次数存起来了。

# 3. 上线

### 3.1 测试服部署

当时采用的是域名+"/test"+uri的方式，这样服务器上nginx就要费些功夫去跳转，router又要重写，（虽然感觉rewrite可以解决），但是前端那边localstorge不好存，域名相同的情况下，直接存很容易就混了。

### 3.2 内测

这是这次治愈系失败的直接原因，由于我们太拖了，后面没内测就直接上线，没有足够的时间修bug，上线后效果很差。

### 3.3 pending

上线前改完bug就直接push，自动部署，重启项目了，所以一直没发现这个问题。每隔一段时间就会所有接口瘫痪，从来没见过这个问题，后来还是请了16的师兄找了好久才找到的。这个问题在上面提到过了，这里再说是想强调错误排查的重要性，当时我们的排查错误的方式都是postman，断点甚至手工断点，原始又暴力。但是面对这种一个人复现不了，一些调试工具也要多加学习，像普通的gotest，dlv等等。